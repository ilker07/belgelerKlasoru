stm32 yi gamepad olarak kullanma device modu.

OTG_FS_DP Digital input/output USB OTG D+ line   PA12
OTG_FS_DM Digital input/output USB OTG D- line   PA11
OTG_FS_ID Digital input USB OTG ID
OTG_FS_VBUS Analog input USB OTG VBUS
OTG_FS_SOF Digital output USB OTG Start Of Frame (visibility)

Core init:

1. Program the following fields in the OTG_FS_GAHBCFG register:
– Global interrupt mask bit GINTMSK = 1
– RxFIFO non-empty (RXFLVL bit in OTG_FS_GINTSTS)
– Periodic TxFIFO empty level
2. Program the following fields in the OTG_FS_GUSBCFG register:
– HNP capable bit 
– SRP capable bit
– FS timeout calibration field
– USB turnaround time field
3. The software must unmask the following bits in the OTG_FS_GINTMSK register:
OTG interrupt mask
Mode mismatch interrupt mask
4. The software can read the CMOD bit in OTG_FS_GINTSTS to determine whether the 
OTG_FS controller is operating in host or device mode

Device init:

1. Program the following fields in the OTG_FS_DCFG register:
– Device speed
– Non-zero-length status OUT handshake
2. Program the OTG_FS_GINTMSK register to unmask the following interrupts:
– USB reset
– Enumeration done
– Early suspend
– USB suspend
– SOF
3. Program the VBUSBSEN bit in the OTG_FS_GCCFG register to enable VBUS sensing 
in “B” device mode and supply the 5 volts across the pull-up resistor on the DP line.
4. Wait for the USBRST interrupt in OTG_FS_GINTSTS. It indicates that a reset has been 
detected on the USB that lasts for about 10 ms on receiving this interrupt.

Wait for the ENUMDNE interrupt in OTG_FS_GINTSTS. This interrupt indicates the end of 
reset on the USB. On receiving this interrupt, the application must read the OTG_FS_DSTS.


At this point, the device is ready to accept SOF packets and perform control transfers on 
control endpoint 0

Device programming:

Endpoint initialization on USB reset
1. Set the NAK bit for all OUT endpoints
– SNAK = 1 in OTG_FS_DOEPCTLx (for all OUT endpoints)
2. Unmask the following interrupt bits
– INEP0 = 1 in OTG_FS_DAINTMSK (control 0 IN endpoint)
– OUTEP0 = 1 in OTG_FS_DAINTMSK (control 0 OUT endpoint)
– STUP = 1 in DOEPMSK
– XFRC = 1 in DOEPMSK
– XFRC = 1 in DIEPMSK
– TOC = 1 in DIEPMSK
3. Set up the Data FIFO RAM for each of the FIFOs
– Program the OTG_FS_GRXFSIZ register, to be able to receive control OUT data 
and setup data. If thresholding is not enabled, at a minimum, this must be equal to 
1 max packet size of control endpoint 0 + 2 words (for the status of the control 
OUT data packet) + 10 words (for setup packets).
– Program the OTG_FS_TX0FSIZ register (depending on the FIFO number chosen) 
to be able to transmit control IN data. At a minimum, this must be equal to 1 max 
packet size of control endpoint 0.
4. Program the following fields in the endpoint-specific registers for control OUT endpoint 
0 to receive a SETUP packet
– STUPCNT = 3 in OTG_FS_DOEPTSIZ0 (to receive up to 3 back-to-back SETUP 
packets)
At this point, all initialization required to receive SETUP packets is done


Endpoint initialization on enumeration completion
1. On the Enumeration Done interrupt (ENUMDNE in OTG_FS_GINTSTS), read the 
OTG_FS_DSTS register to determine the enumeration speed.
2. Program the MPSIZ field in OTG_FS_DIEPCTL0 to set the maximum packet size. This 
step configures control endpoint 0. The maximum packet size for a control endpoint 
depends on the enumeration speed.

At this point, the device is ready to receive SOF packets and is configured to perform control 
transfers on control endpoint 0.
Endpoint initialization on SetAddress command
This section describes what the application must do when it receives a SetAddress 
command in a SETUP packet.
1. Program the OTG_FS_DCFG register with the device address received in the 
SetAddress command
2. Program the core to send out a status IN packet
Endpoint initialization on SetConfiguration/SetInterface command
This section describes what the application must do when it receives a SetConfiguration or 
SetInterface command in a SETUP packet.
1. When a SetConfiguration command is received, the application must program the 
endpoint registers to configure them with the characteristics of the valid endpoints in 
the new configuration.
2. When a SetInterface command is received, the application must program the endpoint 
registers of the endpoints affected by this command.
3. Some endpoints that were active in the prior configuration or alternate setting are not 
valid in the new configuration or alternate setting. These invalid endpoints must be 
deactivated.
4. Unmask the interrupt for each active endpoint and mask the interrupts for all inactive 
endpoints in the OTG_FS_DAINTMSK register.
5. Set up the Data FIFO RAM for each FIFO.
6. After all required endpoints are configured; the application must program the core to 
send a status IN packet.
At this point, the device core is configured to receive and transmit any type of data packet.
Endpoint activation
This section describes the steps required to activate a device endpoint or to configure an 
existing device endpoint to a new type.
1. Program the characteristics of the required endpoint into the following fields of the 
OTG_FS_DIEPCTLx register (for IN or bidirectional endpoints) or the 
OTG_FS_DOEPCTLx register (for OUT or bidirectional endpoints).
– Maximum packet size
– USB active endpoint = 1
– Endpoint start data toggle (for interrupt and bulk endpoints)
– Endpoint type
– TxFIFO number
2. Once the endpoint is activated, the core starts decoding the tokens addressed to that 
endpoint and sends out a valid handshake for each valid token received for the 
endpoint


Endpoint deactivation
This section describes the steps required to deactivate an existing endpoint.
1. In the endpoint to be deactivated, clear the USB active endpoint bit in the 
OTG_FS_DIEPCTLx register (for IN or bidirectional endpoints) or the 
OTG_FS_DOEPCTLx register (for OUT or bidirectional endpoints).
2. Once the endpoint is deactivated, the core ignores tokens addressed to that endpoint, 
which results in a timeout on the USB.
Note: The application must meet the following conditions to set up the device core to handle 
traffic:
NPTXFEM and RXFLVLM in the OTG_FS_GINTMSK register must be cleared

Operational model:

SETUP and OUT data transfers
This section describes the internal data flow and application-level operations during data 
OUT transfers and SETUP transactions.
• Packet read
This section describes how to read packets (OUT data and SETUP packets) from the 
receive FIFO.
1. On catching an RXFLVL interrupt (OTG_FS_GINTSTS register), the application must 
read the Receive status pop register (OTG_FS_GRXSTSP).
2. The application can mask the RXFLVL interrupt (in OTG_FS_GINTSTS) by writing to 
RXFLVL = 0 (in OTG_FS_GINTMSK), until it has read the packet from the receive 
FIFO.
3. If the received packet’s byte count is not 0, the byte count amount of data is popped 
from the receive Data FIFO and stored in memory. If the received packet byte count is 
0, no data is popped from the receive data FIFO.
4. The receive FIFO’s packet status readout indicates one of the following:
a) Global OUT NAK pattern:
PKTSTS = Global OUT NAK, BCNT = 0x000, EPNUM = Don’t Care (0x0), 
DPID = Don’t Care (0b00).
These data indicate that the global OUT NAK bit has taken effect.
b) SETUP packet pattern:
PKTSTS = SETUP, BCNT = 0x008, EPNUM = Control EP Num, DPID = D0. 
These data indicate that a SETUP packet for the specified endpoint is now 
available for reading from the receive FIFO.
c) Setup stage done pattern:
PKTSTS = Setup Stage Done, BCNT = 0x0, EPNUM = Control EP Num, 
DPID = Don’t Care (0b00).
These data indicate that the Setup stage for the specified endpoint has completed 
and the Data stage has started. After this entry is popped from the receive FIFO, 
the core asserts a Setup interrupt on the specified control OUT endpoint.
d) Data OUT packet pattern:
PKTSTS = DataOUT, BCNT = size of the received data OUT packet (0 ≤ BCNT 
≤ 1 024), EPNUM = EPNUM on which the packet was received, DPID = Actual 
Data PID.


e) Data transfer completed pattern:
PKTSTS = Data OUT Transfer Done, BCNT = 0x0, EPNUM = OUT EP Num 
on which the data transfer is complete, DPID = Don’t Care (0b00).
These data indicate that an OUT data transfer for the specified OUT endpoint has 
completed. After this entry is popped from the receive FIFO, the core asserts a 
Transfer Completed interrupt on the specified OUT endpoint.
5. After the data payload is popped from the receive FIFO, the RXFLVL interrupt 
(OTG_FS_GINTSTS) must be unmasked.
6. Steps 1–5 are repeated every time the application detects assertion of the interrupt line 
due to RXFLVL in OTG_FS_GINTSTS. Reading an empty receive FIFO can result in 
undefined core behavior.







